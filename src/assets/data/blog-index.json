[{"id": "1", "title": "Vue 3 Composition API 最佳实践", "excerpt": "深入探讨 Vue 3 Composition API 的使用技巧和最佳实践，包括响应式原理、组合式函数设计、依赖注入等核心概念，帮助你写出更优雅的 Vue 3 代码。", "content": "Vue 3 的 Composition API 是一个强大的特性，它改变了我们编写 Vue 组件的方式。本文将深入探讨 Composition API 的核心概念和最佳实践。\n\n## 1. 响应式系统基础\n\nVue 3 的响应式系统基于 ES6 的 Proxy，相比 Vue 2 的 Object.defineProperty 有更好的性能和更少的限制。\n\n```typescript\nimport { ref, reactive, computed } from 'vue'\n\n// ref 用于基本类型\nconst count = ref(0)\n\n// reactive 用于对象\nconst state = reactive({\n  name: 'Vue 3',\n  version: 3\n})\n\n// computed 用于计算属性\nconst doubled = computed(() => count.value * 2)\n```\n\n## 2. 组合式函数设计\n\n组合式函数（Composables）是 Composition API 的核心，它允许我们将逻辑提取到可复用的函数中。\n\n```typescript\n// useCounter.ts\nimport { ref, computed } from 'vue'\n\nexport function useCounter(initialValue = 0) {\n  const count = ref(initialValue)\n  const doubled = computed(() => count.value * 2)\n\n  function increment() {\n    count.value++\n  }\n\n  function decrement() {\n    count.value--\n  }\n\n  return {\n    count,\n    doubled,\n    increment,\n    decrement\n  }\n}\n```\n\n## 3. 依赖注入\n\nVue 3 的 provide/inject API 使得跨组件通信更加优雅。\n\n```typescript\n// 父组件\nimport { provide, ref } from 'vue'\n\nconst theme = ref('light')\nprovide('theme', theme)\n\n// 子组件\nimport { inject } from 'vue'\n\nconst theme = inject('theme', ref('light'))\n```\n\n## 4. 最佳实践总结\n\n1. **使用 ref 还是 reactive**：基本类型用 ref，对象用 reactive\n2. **避免过度解构**：解构会丢失响应性，使用 toRefs\n3. **合理使用 computed**：用于计算属性，避免在模板中写复杂逻辑\n4. **组合式函数命名**：以 use 开头，如 useCounter、useFetch\n5. **类型安全**：充分利用 TypeScript 的类型推断\n\nComposition API 让 Vue 3 的代码更加灵活和可维护，掌握它将大大提升你的开发效率。", "author": "佘杰", "publishedAt": "2024-01-15", "updatedAt": "2024-01-15", "tags": ["Vue 3", "Composition API", "TypeScript"], "readTime": 15, "coverImage": "/images/blog/blog1.jpg", "featured": true}, {"id": "2", "title": "TypeScript 高级类型技巧", "excerpt": "掌握 TypeScript 高级类型系统，包括泛型、条件类型、映射类型、模板字面量类型等，提升代码的类型安全性和可维护性。", "content": "TypeScript 的类型系统是其最强大的特性之一。本文将深入探讨 TypeScript 的高级类型技巧。\n\n## 1. 泛型基础\n\n泛型允许我们创建可重用的组件，同时保持类型安全。\n\n```typescript\nfunction identity<T>(arg: T): T {\n  return arg\n}\n\n// 使用\nconst result = identity<string>('hello')\n```\n\n## 2. 条件类型\n\n条件类型允许我们根据类型关系选择类型。\n\n```typescript\ntype NonNullable<T> = T extends null | undefined ? never : T\n\ntype TypeName<T> =\n  T extends string ? 'string' :\n  T extends number ? 'number' :\n  T extends boolean ? 'boolean' :\n  T extends undefined ? 'undefined' :\n  T extends Function ? 'function' :\n  'object'\n```\n\n## 3. 映射类型\n\n映射类型允许我们基于现有类型创建新类型。\n\n```typescript\ntype Readonly<T> = {\n  readonly [P in keyof T]: T[P]\n}\n\ntype Partial<T> = {\n  [P in keyof T]?: T[P]\n}\n\ntype Required<T> = {\n  [P in keyof T]-?: T[P]\n}\n```\n\n## 4. 模板字面量类型\n\n模板字面量类型允许我们基于字符串模式创建类型。\n\n```typescript\ntype EventName<T extends string> = `on${Capitalize<T>}`\n\ntype Event = EventName<'click' | 'scroll'>\n// 等价于 'onClick' | 'onScroll'\n```\n\n## 5. 实用工具类型\n\nTypeScript 提供了许多内置的实用工具类型。\n\n```typescript\n// Pick - 选择部分属性\ntype User = {\n  id: number\n  name: string\n  email: string\n}\n\ntype UserPreview = Pick<User, 'name' | 'email'>\n\n// Omit - 排除部分属性\ntype UserWithoutId = Omit<User, 'id'>\n\n// Record - 创建对象类型\ntype UserMap = Record<string, User>\n```\n\n## 6. 类型推断\n\n合理使用类型推断可以减少冗余的类型注解。\n\n```typescript\n// ReturnType - 获取函数返回值类型\ntype Fn = () => string\ntype Result = ReturnType<Fn> // string\n\n// Parameters - 获取函数参数类型\ntype Params = Parameters<typeof fn>\n```\n\n掌握这些高级类型技巧，将帮助你写出更加类型安全和可维护的代码。", "author": "佘杰", "publishedAt": "2024-02-10", "updatedAt": "2024-02-10", "tags": ["TypeScript", "类型系统", "泛型"], "readTime": 20, "coverImage": "/images/blog/blog2.jpg", "featured": true}, {"id": "3", "title": "Vite 构建工具深度实践", "excerpt": "探索 Vite 的核心原理和高级配置，包括插件开发、构建优化、性能调优等，帮助你构建更快的开发体验和生产构建。", "content": "Vite 是新一代前端构建工具，它利用浏览器的 ES Module 原生支持，提供了极快的开发服务器启动速度和热更新。\n\n## 1. Vite 核心原理\n\nVite 的核心优势在于利用浏览器的 ES Module 支持，在开发环境中直接编译和提供模块，无需打包。\n\n### 开发环境\n```\n浏览器请求 → Vite 服务器 → 按需编译 → 返回 ES Module\n```\n\n### 生产环境\n```\n源代码 → Rollup 打包 → 优化输出 → 静态资源\n```\n\n## 2. 插件开发\n\nVite 插件基于 Rollup 插件系统，可以扩展 Vite 的功能。\n\n```typescript\n// my-plugin.ts\nimport type { Plugin } from 'vite'\n\nexport function myPlugin(): Plugin {\n  return {\n    name: 'my-plugin',\n    resolveId(source) {\n      if (source === 'virtual-module') {\n        return source\n      }\n    },\n    load(id) {\n      if (id === 'virtual-module') {\n        return 'export const msg = \"Hello from plugin\"'\n      }\n    }\n  }\n}\n\n// vite.config.ts\nimport { defineConfig } from 'vite'\nimport { myPlugin } from './my-plugin'\n\nexport default defineConfig({\n  plugins: [myPlugin()]\n})\n```\n\n## 3. 构建优化\n\n### 代码分割\n\n```typescript\nexport default defineConfig({\n  build: {\n    rollupOptions: {\n      output: {\n        manualChunks(id) {\n          if (id.includes('node_modules')) {\n            return 'vendor'\n          }\n        }\n      }\n    }\n  }\n})\n```\n\n### 压缩和优化\n\n```typescript\nimport viteCompression from 'vite-plugin-compression'\n\nexport default defineConfig({\n  plugins: [\n    viteCompression({\n      algorithm: 'gzip',\n      ext: '.gz'\n    })\n  ]\n})\n```\n\n## 4. 性能调优\n\n### 预构建优化\n\n```typescript\nexport default defineConfig({\n  optimizeDeps: {\n    include: ['vue', 'vue-router'],\n    exclude: ['some-large-library']\n  }\n})\n```\n\n### 开发服务器配置\n\n```typescript\nexport default defineConfig({\n  server: {\n    port: 3000,\n    open: true,\n    proxy: {\n      '/api': 'http://localhost:8080'\n    }\n  }\n})\n```\n\n## 5. 最佳实践\n\n1. **合理使用预构建**：将常用依赖预构建\n2. **优化依赖**：排除不需要预构建的依赖\n3. **代码分割**：按路由或功能分割代码\n4. **使用 CDN**：将大型依赖放到 CDN\n5. **启用压缩**：使用 Gzip 或 Brotli 压缩\n\nVite 的快速开发体验和优秀的构建性能，使其成为现代前端项目的首选构建工具。", "author": "佘杰", "publishedAt": "2024-03-05", "updatedAt": "2024-03-05", "tags": ["Vite", "构建工具", "性能优化"], "readTime": 18, "coverImage": "/images/blog/blog3.jpg", "featured": true}, {"id": "4", "title": "前端性能优化实战指南", "excerpt": "全面解析前端性能优化的各个方面，包括资源加载优化、渲染性能优化、网络优化等，帮助你打造极速的 Web 应用。", "content": "前端性能优化是提升用户体验的关键。本文将从多个维度介绍前端性能优化的实战技巧。\n\n## 1. 资源加载优化\n\n### 懒加载\n\n```typescript\n// 路由懒加载\nconst Home = () => import('./views/Home.vue')\n\n// 组件懒加载\nconst LazyComponent = defineAsyncComponent(() =>\n  import('./components/LazyComponent.vue')\n)\n```\n\n### 图片优化\n\n```html\n<!-- 使用 WebP 格式 -->\n<picture>\n  <source srcset=\"image.webp\" type=\"image/webp\">\n  <source srcset=\"image.jpg\" type=\"image/jpeg\">\n  <img src=\"image.jpg\" alt=\"描述\" loading=\"lazy\">\n</picture>\n```\n\n### 预加载和预连接\n\n```html\n<link rel=\"preload\" href=\"font.woff2\" as=\"font\" type=\"font/woff2\" crossorigin>\n<link rel=\"preconnect\" href=\"https://api.example.com\">\n```\n\n## 2. 渲染性能优化\n\n### 虚拟滚动\n\n对于长列表，使用虚拟滚动只渲染可见区域的元素。\n\n```typescript\nimport { useVirtualList } from '@vueuse/core'\n\nconst { list, containerProps, wrapperProps } = useVirtualList(\n  Array.from({ length: 10000 }, (_, i) => ({ id: i })),\n  { itemHeight: 50 }\n)\n```\n\n### 防抖和节流\n\n```typescript\nimport { useDebounceFn, useThrottleFn } from '@vueuse/core'\n\nconst debouncedSearch = useDebounceFn((query: string) => {\n  // 搜索逻辑\n}, 300)\n\nconst throttledScroll = useThrottleFn(() => {\n  // 滚动逻辑\n}, 100)\n```\n\n### 减少重排和重绘\n\n```typescript\n// 批量更新 DOM\nconst element = document.getElementById('element')\nelement.style.opacity = '0'\nelement.style.transform = 'translateX(0)'\n\n// 使用 transform 代替 top/left\n// 使用 opacity 代替 display\n```\n\n## 3. 网络优化\n\n### HTTP/2 和 HTTP/3\n\n确保服务器支持 HTTP/2 和 HTTP/3，以获得更好的性能。\n\n### 缓存策略\n\n```typescript\n// Service Worker 缓存\nself.addEventListener('fetch', (event) => {\n  event.respondWith(\n    caches.match(event.request).then((response) => {\n      return response || fetch(event.request)\n    })\n  )\n})\n```\n\n### CDN 加速\n\n将静态资源部署到 CDN，减少网络延迟。\n\n## 4. 代码优化\n\n### Tree Shaking\n\n确保构建工具启用 Tree Shaking，移除未使用的代码。\n\n```typescript\n// vite.config.ts\nexport default defineConfig({\n  build: {\n    rollupOptions: {\n      output: {\n        manualChunks(id) {\n          if (id.includes('node_modules')) {\n            return 'vendor'\n          }\n        }\n      }\n    }\n  }\n})\n```\n\n### 减少包体积\n\n```typescript\n// 使用按需引入\nimport { Button } from 'element-plus'\n\n// 而不是\nimport ElementPlus from 'element-plus'\n```\n\n## 5. 监控和分析\n\n### Lighthouse\n\n使用 Lighthouse 进行性能审计。\n\n```bash\nnpx lighthouse https://example.com --view\n```\n\n### Web Vitals\n\n监控核心 Web 指标。\n\n```typescript\nimport { onCLS, onFID, onLCP } from 'web-vitals'\n\nonCLS(console.log)\nonFID(console.log)\nonLCP(console.log)\n```\n\n性能优化是一个持续的过程，需要不断监控和改进。通过合理的优化策略，可以显著提升用户体验。", "author": "佘杰", "publishedAt": "2024-04-20", "updatedAt": "2024-04-20", "tags": ["性能优化", "前端", "Web 性能"], "readTime": 25, "coverImage": "/images/blog/blog4.jpg", "featured": true}, {"id": "5", "title": "Pinia 状态管理最佳实践", "excerpt": "深入探讨 Pinia 状态管理的使用技巧和最佳实践，包括 Store 设计、状态持久化、模块化等，帮助你构建可维护的状态管理方案。", "content": "Pinia 是 Vue 3 官方推荐的状态管理库，它简单、轻量且类型安全。本文将介绍 Pinia 的最佳实践。\n\n## 1. Store 设计原则\n\n### 单一职责\n\n每个 Store 应该只负责一个领域的状态。\n\n```typescript\n// stores/useUserStore.ts\nexport const useUserStore = defineStore('user', () => {\n  const user = ref<User | null>(null)\n  const isAuthenticated = computed(() => !!user.value)\n\n  async function login(credentials: LoginCredentials) {\n    const response = await api.login(credentials)\n    user.value = response.data\n  }\n\n  function logout() {\n    user.value = null\n  }\n\n  return { user, isAuthenticated, login, logout }\n})\n```\n\n### 使用 Composition API 风格\n\nPinia 2.0+ 推荐使用 Composition API 风格。\n\n```typescript\nexport const useCounterStore = defineStore('counter', () => {\n  const count = ref(0)\n  const doubled = computed(() => count.value * 2)\n\n  function increment() {\n    count.value++\n  }\n\n  return { count, doubled, increment }\n})\n```\n\n## 2. 状态持久化\n\n### 使用插件\n\n```typescript\nimport { createPinia } from 'pinia'\nimport piniaPluginPersistedstate from 'pinia-plugin-persistedstate'\n\nconst pinia = createPinia()\npinia.use(piniaPluginPersistedstate)\n\nexport const useUserStore = defineStore('user', () => {\n  // ...\n}, {\n  persist: {\n    key: 'user-store',\n    storage: localStorage,\n    paths: ['user'] // 只持久化部分状态\n  }\n})\n```\n\n## 3. 模块化设计\n\n### 按功能拆分\n\n```\nstores/\n├── user/\n│   ├── index.ts\n│   ├── types.ts\n│   └── api.ts\n├── product/\n│   ├── index.ts\n│   ├── types.ts\n│   └── api.ts\n└── index.ts\n```\n\n## 4. 类型安全\n\n### 定义类型\n\n```typescript\n// types.ts\nexport interface User {\n  id: number\n  name: string\n  email: string\n}\n\nexport interface LoginCredentials {\n  email: string\n  password: string\n}\n```\n\n### 使用类型\n\n```typescript\nexport const useUserStore = defineStore('user', () => {\n  const user = ref<User | null>(null)\n\n  async function login(credentials: LoginCredentials) {\n    // 类型安全的实现\n  }\n\n  return { user, login }\n})\n```\n\n## 5. 最佳实践\n\n1. **使用 computed**：将派生状态定义为 computed\n2. **避免深层嵌套**：保持状态结构扁平\n3. **合理使用 actions**：异步操作放在 actions 中\n4. **命名规范**：Store 和函数使用清晰的命名\n5. **类型安全**：充分利用 TypeScript 的类型检查\n\nPinia 的简洁设计和强大的类型系统，使其成为 Vue 3 状态管理的最佳选择。", "author": "佘杰", "publishedAt": "2024-05-15", "updatedAt": "2024-05-15", "tags": ["Pinia", "状态管理", "Vue 3"], "readTime": 16, "coverImage": "/images/blog/blog5.jpg", "featured": true}]